<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>DTS Application Library: Referenced Lockable Objects</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DTS Application Library
   &#160;<span id="projectnumber">0.2.3</span>
   </div>
   <div id="projectbrief">Application library containing referenced objects and interfaces to common libraries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('refobj.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Referenced Lockable Objects </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="refobjinfo"></a>
Introduction</h1>
<p>Data structures in C are are simple by nature well defined and logical. Using pointers is almost imperitive for performance issues copying chunks of data onto the limited space on the stack is not the best solution.</p>
<p>For these same reasons you would use dynamically allocated memory (malloc/calloc) and assign it to your struct, a very important reason not to do it on the stack is that when you leave the function the stack space is feeed.</p>
<p>So assuming all data structs are pointers the only access to the data is via these pointers the pointers can be copied and overwriten as needed the memory is available till freed.</p>
<p>take the following code into account</p>
<pre class="fragment">  struct cust *c1, *c2, *c3, c4;
 
  c1 = malloc(sizeof(struct cust));
  c2 = malloc(sizeof(struct cust));
  c3 = malloc(sizeof(struct cust));

  .... assign the data ....

  if (c1-&gt;priority &lt; c3-&gt;priority) {
    c4 = c1;
    c1 = c3;
    c3 = c4;
  }</pre><p>It is clear that its possible that c4 and c3 are pointing to the identical memory here is where the problem starts if i free c4 and then try access c3 its possible that the data will be corrupted or reassigned causeing unpredictable results.</p>
<p>This is the first problem referenced objects solve that no memory will be freed while a referece is held for the object. use of <a class="el" href="group___l_i_b-_o_b_j.html#ga21cf8972a38aed3f153f4ed06b12a419" title="Allocate a referenced lockable object. ">objalloc()</a> instead of malloc/calloc will return a pointer to the allocated memory just as before but now when we want to copy the pointer and ensure it persists we can refrence it using <a class="el" href="group___l_i_b-_o_b_j.html#ga3a67a6d45e39f530beb6e45b6b7e7d3b" title="Reference a object. ">objref()</a> and release the refrence with <a class="el" href="group___l_i_b-_o_b_j.html#ga88a966a194cdf36fe9b5be0917ce86d9" title="Drop reference held. ">objunref()</a> if the refrence count is 0 the object will be freed the current count is returned by <a class="el" href="group___l_i_b-_o_b_j.html#gaadae6dadb10585b603953ed7f1c530ba" title="Return current reference count. ">objcnt()</a>.</p>
<p>lets look at the code again but using refereneced objects of course if c4 is a tmp variable that wont change and be used again there is no need to do this we assuming that this is uncertain and taking precautions.</p>
<pre class="fragment">  struct cust *c1, *c2, *c3, c4;
 
  c1 = objalloc(sizeof(strict cust), NULL);
  c2 = objalloc(sizeof(struct cust), NULL);
  c3 = objalloc(sizeof(struct cust), NULL);

  .... assign the data ....

  if (c1-&gt;priority &lt; c3-&gt;priority) {
    /*grab a new ref for c1 and pass to c4*/
    c4 = (objref(c1)) ? c1 : NULL;

    /*grab ref for c3 and pass to c1*/;
    c1 = (objref(c3)) ? c3 : NULL;

    /* pass the ref of c4 to c3*/
    c3 = c4;
    /* release the reference for old c3 now c1*/
    objunref(c1);

    /* we now have 2 refs to c3 the original c1 and one ref for the others.*/
  }</pre><p>The second parameter of <a class="el" href="group___l_i_b-_o_b_j.html#ga21cf8972a38aed3f153f4ed06b12a419" title="Allocate a referenced lockable object. ">objalloc()</a> is the "destructor" this is a function callback to cleanup the data before it is freed by objunref.</p>
<p>This is a slightly pointless bit of code but you should notice that we have called objref 2 and objunref 1 you should also see that reference can be passed with the pointer. The original c1 is now referenced 2 once in c4 and once in c3. the reason we dont just call objref on c4 at the end is in multi threaded applications its possible to have things get scrambled and a item freed in another thread before you reference it its best to always call objref before copying the reference use of locking is needed in some circumstances. if you want to grab a reference to a shared memory location that is "changeable" locking is required.</p>
<p>this is done implicitly with <a class="el" href="group___l_i_b-_o_b_j.html#ga3a67a6d45e39f530beb6e45b6b7e7d3b" title="Reference a object. ">objref()</a> / <a class="el" href="group___l_i_b-_o_b_j.html#ga88a966a194cdf36fe9b5be0917ce86d9" title="Drop reference held. ">objunref()</a> the reference is obtained atomically the return value of objref should be checked it it is 0 then the referenced failed also to prevent a dead lock never call objref while holding the lock for the reference.</p>
<h1><a class="anchor" id="refobjother"></a>
Other referenced object functions.</h1>
<p>Referenced objects can be locked and unlocked but not reentrantly (this is a design choice and can be made optional). the functions <a class="el" href="group___l_i_b-_o_b_j.html#ga4af4ae14c4a3e9f3037a09237bcfeae3" title="Lock the reference. ">objlock()</a> will lock and <a class="el" href="group___l_i_b-_o_b_j.html#ga8c73b68730aa4452357e84af27e00008" title="Unlock a reference. ">objunlock()</a> will unlock referenced objects a lock can be attempted using <a class="el" href="group___l_i_b-_o_b_j.html#gacb8f70e50130ab83c5f0eab4b96f72b5" title="Try lock a reference. ">objtrylock()</a>.</p>
<p>The size of the requested memory is available by calling <a class="el" href="group___l_i_b-_o_b_j.html#ga96edfbac62564eb7424d8ed2dddfbe1b" title="Size requested for data. ">objsize()</a> returning a new reference to a string is done with <a class="el" href="group___l_i_b-_o_b_j.html#ga6f31c0e1694ff10b71f6e655d8383b01" title="Return a reference to copy of a buffer. ">objchar()</a>.</p>
<p>The macros <a class="el" href="group___l_i_b-_o_b_j.html#gad2acae829630a5df6b23d108520c71c2">setflag</a> <a class="el" href="group___l_i_b-_o_b_j.html#ga0d5eb5885263228f57b0dba4dc8d90fa">clearflag</a> and <a class="el" href="group___l_i_b-_o_b_j.html#gaaf8bc071257e95e30652a7b211b61315">testflag</a> for atomically handling flags.</p>
<h1><a class="anchor" id="refobjint"></a>
Internal workings.</h1>
<p>There is no voodo or black magic to the workings of a referenced object they are all <a class="el" href="structref__obj.html" title="Internal structure of all referenced objects. ">ref_obj</a> structures.</p>
<p>When <a class="el" href="group___l_i_b-_o_b_j.html#ga21cf8972a38aed3f153f4ed06b12a419" title="Allocate a referenced lockable object. ">objalloc()</a> is called a a block of memmory the size requested + the size of <a class="el" href="structref__obj.html" title="Internal structure of all referenced objects. ">ref_obj</a> is allocatted and a pointer to data is returned and the data is set to the to the block after the <a class="el" href="structref__obj.html" title="Internal structure of all referenced objects. ">ref_obj</a>. when the objXXX() functions are called the pointer provided is rewound to the begining of the <a class="el" href="structref__obj.html" title="Internal structure of all referenced objects. ">ref_obj</a> the value of <a class="el" href="structref__obj.html#a31084d3309cb4bed56ac592d0a29e3e5" title="Memory integrity check used to prevent non refeferenced objects been handled as referenced objects...">ref_obj::magic</a> is checked to ensure that it is a referenced object and -1 is returned if it is not.</p>
<p><a class="el" href="group___l_i_b-_o_b_j.html#ga4af4ae14c4a3e9f3037a09237bcfeae3" title="Lock the reference. ">objlock()</a> / <a class="el" href="group___l_i_b-_o_b_j.html#ga8c73b68730aa4452357e84af27e00008" title="Unlock a reference. ">objunlock()</a> / <a class="el" href="group___l_i_b-_o_b_j.html#gacb8f70e50130ab83c5f0eab4b96f72b5" title="Try lock a reference. ">objtrylock()</a> will lock the mutex <a class="el" href="structref__obj.html#a63af58e8d5b98a6f9d8fba0f335e889d" title="this is a pointer to the lock it may be changed to be the lock ">ref_obj::lock</a>.</p>
<p><a class="el" href="group___l_i_b-_o_b_j.html#ga3a67a6d45e39f530beb6e45b6b7e7d3b" title="Reference a object. ">objref()</a> / <a class="el" href="group___l_i_b-_o_b_j.html#ga88a966a194cdf36fe9b5be0917ce86d9" title="Drop reference held. ">objunref()</a> will first lock <a class="el" href="structref__obj.html#a63af58e8d5b98a6f9d8fba0f335e889d" title="this is a pointer to the lock it may be changed to be the lock ">ref_obj::lock</a> then alter <a class="el" href="structref__obj.html#a9f9b349333420bc708187ef7fd7f0984" title="Reference count the oject will be freed when the reference count reaches 0. ">ref_obj::cnt</a> when the count reaches 0 the destructor callback <a class="el" href="structref__obj.html#a57d9b7cd22f5680beb35e00d31bc9fc5" title="Function to call to clean up the data before its freed. ">ref_obj::destroy</a> is called with <a class="el" href="structref__obj.html#a4725a0b14472b6571c3901ccc71bae08" title="Pointer to the data referenced. ">ref_obj::data</a> and on return the memory is freed. this is very similar to a C++ destructor.</p>
<p><a class="el" href="group___l_i_b-_o_b_j.html#gaadae6dadb10585b603953ed7f1c530ba" title="Return current reference count. ">objcnt()</a> returns the value of <a class="el" href="structref__obj.html#a9f9b349333420bc708187ef7fd7f0984" title="Reference count the oject will be freed when the reference count reaches 0. ">ref_obj::cnt</a> obtained while <a class="el" href="structref__obj.html#a63af58e8d5b98a6f9d8fba0f335e889d" title="this is a pointer to the lock it may be changed to be the lock ">ref_obj::lock</a> is held or -1 on error it is a error to return 0 as <a class="el" href="structref__obj.html#a31084d3309cb4bed56ac592d0a29e3e5" title="Memory integrity check used to prevent non refeferenced objects been handled as referenced objects...">ref_obj::magic</a> is set to zero when the count reaches 0.</p>
<p><a class="el" href="group___l_i_b-_o_b_j.html#ga96edfbac62564eb7424d8ed2dddfbe1b" title="Size requested for data. ">objsize()</a> returns <a class="el" href="structref__obj.html#ab77479cff3d660fbd7af49c237975b1c" title="The size allocated to this object. ">ref_obj::size</a> this contains the size of the memmory allocated (total).</p>
<h1><a class="anchor" id="refobjcpp"></a>
Referenced Lockable Objects With Classes (C++)</h1>
<p>C++ classes implement destructors but do not implement reference counting by overloading the new/delete operators it is possible to use referenced objects with C++ classes.</p>
<p>include the macro DTS_OJBREF_CLAS in your C++ class as follows. as it declares the destructor this does not need to be redeclared.</p>
<pre class="fragment">class somecool_class {
    public:
        DTS_OJBREF_CLASS(somecool_class);
...........
...........
}
</pre><p>The macro is included below internally it replaces new with objalloc and calls the cleanup routine it creates this calls delete that will run the destructor.</p>
<pre class="fragment">void *operator new(size_t sz) {\
    return objalloc(sz, &amp;classtype::dts_unref_classtype);\
}\
void operator delete(void *obj) {\
}\
static void dts_unref_classtype(void *data) {\
    delete (classtype*)data;\
}\
~classtype()
</pre> <dl class="section note"><dt>Note</dt><dd>This should only be used when there is no inheritance. </dd></dl>
<h1><a class="anchor" id="refobjneg"></a>
Downsides</h1>
<p>It adds <a class="el" href="structref__obj.html" title="Internal structure of all referenced objects. ">ref_obj</a> size memory to each referenced object this includes the size of the lock structure, however with almost all programs but the simplest benifiting from multi threading this is only a disadvantage in the simplest programs.</p>
<p>On a 32bit system 20bytes is used for <a class="el" href="structref__obj.html" title="Internal structure of all referenced objects. ">ref_obj</a> and on 64bit 32bytes is used excluding the size of the lock 24bytes and 40bytes respectivly, taaking into account the availability of memory and the benifits this will be acceptable.</p>
<p>One option is to drop support for <a class="el" href="group___l_i_b-_o_b_j.html#ga96edfbac62564eb7424d8ed2dddfbe1b" title="Size requested for data. ">objsize()</a> this will save 4bytes and 8 bytes respectivly removing the magic cookie is not recomended. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Oct 23 2013 10:44:29 for DTS Application Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
